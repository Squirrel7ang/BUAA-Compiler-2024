% \author{22371027-汤睿璟}
% 设置页面边距（word标准页面）
\documentclass[a4paper]{article}
\usepackage{cite} % 加在文章最开头，表示你这篇文章要引用别的东西。
\usepackage{geometry}
\geometry{a4paper,left=2.7cm,right=2.7cm,top=2.54cm,bottom=2.54cm}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usepackage{wrapfig}


%导入ctex包
\usepackage[UTF8,heading=true]{ctex}
\tikzset{
	startstop/.style={
		rectangle,
		rounded corners,
		minimum width=3cm,
		minimum height=1cm,
		text centered,
		draw=black,
		fill=red!30
	},
	io/.style={
		trapezium,
		trapezium left angle=70,
		trapezium right angle=110,
		minimum width=3cm,
		minimum height=1cm,
		text centered,
		draw=black,
		fill=blue!30
	},
	process/.style={
		rectangle,
		minimum width=3cm,
		minimum height=1cm,
		text centered,
		draw=black,
		fill=orange!30
	},
	decision/.style={
		diamond,
		aspect=2, % 控制菱形的宽高比
		minimum width=3cm,
		minimum height=1cm,
		text centered,
		draw=black,
		fill=green!30
	},
	arrow/.style={
		thick,
		-Stealth % 使用Stealth箭头样式
	}
}

%设置摘要格式
\usepackage{abstract}
\setlength{\abstitleskip}{0em}
\setlength{\absleftindent}{0pt}
\setlength{\absrightindent}{0pt}
\setlength{\absparsep}{0em}
\renewcommand{\abstractname}{\textbf{\zihao{4}{摘要}}}
\renewcommand{\abstracttextfont}{\zihao{-4}} %设置摘要正文字号

%设置页眉和页脚，只显示页脚居中页码
\usepackage{fancyhdr}
\pagestyle{plain}

%调用数学公式包
\usepackage{amssymb}
\usepackage{amsmath}

%调用浮动包
\usepackage{float}
\usepackage{subfig}
% \captionsetup[figure]{labelsep=space} %去除图标题的冒号
% \captionsetup[table]{labelsep=space} %去除表格标题的冒号
%设置标题格式
\ctexset {
	%设置一级标题的格式
	section = {
		name={,、},
		number=\chinese{section}, %设置中文版的标题
		aftername=,
	},
	%设置三级标题的格式
	subsubsection = {
		format += \zihao{-4} % 设置三级标题的字号
	}
}


%使得英文字体都为Time NewTown
%\usepackage{times}

%图片包导入
\usepackage{graphicx}
\graphicspath{{figures/}} %图片在当前目录下的figures目录

%参考文献包引入
\usepackage{cite}
\usepackage[numbers,sort&compress]{natbib}

%代码格式
\usepackage{listings}
\usepackage{graphicx}%写入python代码
\usepackage{pythonhighlight}%python代码高亮显示
\lstset{
	%numbers=left, %设置行号位置
	%	numberstyle=\tiny, %设置行号大小
	keywordstyle=\color{blue}, %设置关键字颜色
	commentstyle=\color[cmyk]{1,0,1,0}, %设置注释颜色
	escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
	breaklines, %自动折行
	extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
	xleftmargin=1em,xrightmargin=1em, aboveskip=1em, %设置边距
	tabsize=4, %设置tab空格数
	showspaces=false %不显示空格
}


\renewcommand{\refname}{}

%item包
\usepackage{enumitem}

%表格加粗
\usepackage{booktabs}

%设置表格间距
\usepackage{caption}

%允许表格长跨页
\usepackage{longtable}

%伪代码用到的宏包
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{accents}

\title{Lab-1 实验报告}
\date{}

\begin{document}
	\maketitle
	\vspace{-6em} %设置摘要与标题的间距
	\zihao{-4} %设置正文字号
	
	\begin{center}22371027-汤睿璟\end{center}
	% \author{22371027-汤睿璟}
	
	\section{参考编译器设计}
	
	编译器主要参考了 Wokron 学长为编译课设计的实例编译器 tolangc。
	
	\textbf{考虑到现在实验课和理论课的进度，该部分内容会在后续的实验中迭代完善。}
	
	\subsection{tolangc}
	
	tolangc 的前端在 libs/tolang 文件夹下，主要由 lexer, parser, AST 和 visiter 四个部分构成，分别处理词法分析、语法分析、抽构建象语法树和中间代码生成四项任务。
	其符号表由 libs/tolang/include/symtable.h 文件中 SymbolTable 类来统一管理。
	前端的错误处理则由 同目录下的 error.h 文件下的 ErrorReporter 完成错误的记录和输出。
	
	前端的文件结构为：
	
	\begin{algorithm}
		tolang \\
		├── CMakeLists.txt\\
		├── include \\
		│   └── tolang \\
		│       ├── ast.h \\
		│       ├── error.h \\
		│       ├── lexer.h \\
		│       ├── parser.h \\ 
		│       ├── symtable.h \\
		│       ├── token.h \\
		│       ├── utils.h \\
		│       └── visitor.h \\
		└── src \\
		├── ast.cpp \\
		├── lexer.cpp \\
		├── parser.cpp \\
		└── visitor.cpp 
	\end{algorithm}
	
	\textbf{后端的文件结构随实验和理论课推进后进行补充。}
	
	\section{编译器总体设计}
	
		本人设计的编译器由前端和后端构成，前端包括词法分析、语法分析、符号表构建和管理、抽象语法树构建和中间代码生成。\textbf{后端的相关内容随实验和理论课推进后进行补充。}
		
		\subsection{接口设计}
		
		词法分析器提供方法 nextToken() 用于返回 Lex 到的下一个 Token，用以分析构建语法树。
	
	\section{词法分析设计}
	
		词法分析器采用自顶向下的分析方法对源代码进行解析，一遍完成文件的读入，并将输入的原文件在对外接口中暴露为 Token 流。 
		Lexer 在 Lex 标识符时会对关键字进行检查，并在可以在 nextToken() 接口中读取到 Lex 到的下一个 Token。
        为了能够同时让词法分析和语法分析能够同时进行，Lexer 不会一次性读取万 nextToken()，而是当 Parser 调用 nextToken() 函数的时候才会进行 Lex 操作。
		
		在编码前，原本预计使用 vector<Token> 将所有读入的 Token 进行保存，再进行处理。后续发现这种处理方式会带来额外的内存开支，并在随后废弃了这种想法。
	
	\section{语法分析设计}

		Parser 本质上是一个自顶向下的语法分析器。他通过不断读取 Lexer 的单词，根据语法规则构建语法数。

        在多数规则中，Parser 可以直接通过查看下一个字符，并和不同候选式的 FIRST 集进行比较来确定用于递归下降的候选式。除此之外，Parser 还作了一些细节上的处理

        \begin{enumerate}
            \item 左递归。在语法的一些规则中出现了左递归的语法规则。对此通过适当改写文法，可以避免左递归问题。
            \item 非 LL 文法。在 Statement 语法成分中，很难通过查看 Lexer 顶端的字符来判断 Statement 下的语法成分。但是注意到对于各个难以判断的候选式，可以通过提取公共前缀来简化规则和判断逻辑，并通过继承属性传递给下层语法成分的 Parser 过程来决定是哪一个语法成分。
        \end{enumerate}
			
        对于每一个非终结符，使用 unique\_ptr 指向非终结符，构建 AST。
			
	\section{语义分析设计}
	
		语义分析的主要工作是构建符号表。通过深度优先搜索遍历 AST 树，即可将符号表构建出来。

		\subsection{符号表管理}

		    本编译器使用栈式符号表对 SysY 对源代码进行分析构建符号表。使用 Symbol 类对 SysY 的对象及对象类型进行分析。

	% \section{语法分析设计}
	
	% \section{错误处理设计}
	
	% \section{代码生成设计}
	
	% \section{代码优化设计}
	
	
	% \begin{figure}[H]
		% 	\centering
		% 	\includegraphics[width=0.7\linewidth]{images/Figure_6.png}
		% 	\caption{训练轮次对模型泛化效果的影响}
		% 	\label{fig:label6}
		% \end{figure}
	
\end{document}
